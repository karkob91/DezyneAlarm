// Generated by dzn code from /home/karol/dev_projects/VerumESP32/DezyneAlarm/src/alarm-interfaces.dzn
// Dezyne --- Dezyne command line tools
// Copyright Â© 2024Karol Kobiela <karol.kobiela@verum.com>
//
// This file is part of Dezyne.
//
// Dezyne is free software: you can redistribute it and/or modify it
// under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// Dezyne is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public
// License along with Dezyne.  If not, see <http://www.gnu.org/licenses/>.
//
// Commentary:
//
// These models represent the actors of the alarm component.
//
// Code:
#include "alarm-interfaces.hh"
#include <dzn/locator.hh>
#include <dzn/runtime.hh>
#include <iterator>
#define STRINGIZING(x) #x
#define STR(x) STRINGIZING (x)
#define LOCATION __FILE__ ":" STR (__LINE__)
IConsole::IConsole (dzn::port::meta const& m)
: dzn_meta (m)
, dzn_share_p (true)
, dzn_label ("")
, dzn_state ()
, state (::IConsole::State::Disarmed)
{}
IConsole::~IConsole ()= default;
void
IConsole::dzn_event (char const* event)
{
  if (!dzn_share_p) return;
  dzn_label = event;
}
void
IConsole::dzn_update_state (dzn::locator const& locator)
{
  if (!dzn_share_p || !dzn_label) return;
  switch (dzn::hash (dzn_label, dzn_state))
    {
      case 2448250764u:
      //0:arm
      dzn_state = 1;
      break;
      case 1227195304u:
      //1:arming
      dzn_state = 6;
      break;
      case 2489929490u:
      //1:false
      dzn_state = 0;
      state = IConsole::State::Disarmed;
      break;
      case 2448250922u:
      //2:arm
      dzn_state = 4;
      break;
      case 4133793833u:
      //2:armed
      dzn_state = 7;
      state = IConsole::State::Armed;
      break;
      case 1417291230u:
      //3:true
      dzn_state = 0;
      state = IConsole::State::Disarmed;
      break;
      case 3242569230u:
      //4:disarmed
      dzn_state = 3;
      break;
      case 2489929727u:
      //4:false
      dzn_state = 2;
      state = IConsole::State::Arming;
      break;
      case 1417291467u:
      //6:true
      dzn_state = 2;
      state = IConsole::State::Arming;
      break;
      case 2448251317u:
      //7:arm
      dzn_state = 8;
      break;
      case 1999778198u:
      //7:detected
      dzn_state = 9;
      state = IConsole::State::Triggered;
      break;
      case 3242569546u:
      //8:disarmed
      dzn_state = 3;
      break;
      case 2489930043u:
      //8:false
      dzn_state = 7;
      state = IConsole::State::Armed;
      break;
      case 2448251475u:
      //9:arm
      dzn_state = 10;
      break;
      case 2759873900u:
      //10:disarmed
      dzn_state = 3;
      break;
      case 3430895307u:
      //10:false
      dzn_state = 9;
      state = IConsole::State::Triggered;
      break;
      default: locator.get<dzn::illegal_handler> ().handle (LOCATION);
    }
}
void
IConsole::dzn_check_bindings ()
{
  if (!this->in.arm) throw dzn::binding_error (this->dzn_meta, "in.arm");
  if (!this->out.armed) throw dzn::binding_error (this->dzn_meta, "out.armed");
  if (!this->out.disarmed) throw dzn::binding_error (this->dzn_meta, "out.disarmed");
  if (!this->out.arming) throw dzn::binding_error (this->dzn_meta, "out.arming");
  if (!this->out.detected) throw dzn::binding_error (this->dzn_meta, "out.detected");
}
namespace dzn
{
}
IPin::IPin (dzn::port::meta const& m)
: dzn_meta (m)
, dzn_share_p (true)
, dzn_label ("")
, dzn_state ()
{}
IPin::~IPin ()= default;
void
IPin::dzn_event (char const* event)
{
  if (!dzn_share_p) return;
  dzn_label = event;
}
void
IPin::dzn_update_state (dzn::locator const& locator)
{
  if (!dzn_share_p || !dzn_label) return;
  switch (dzn::hash (dzn_label, dzn_state))
    {
      case 3509916700u:
      //0:valid
      dzn_state = 1;
      break;
      case 2489929490u:
      //1:false
      dzn_state = 0;
      break;
      case 1417291072u:
      //1:true
      dzn_state = 0;
      break;
      default: locator.get<dzn::illegal_handler> ().handle (LOCATION);
    }
}
void
IPin::dzn_check_bindings ()
{
  if (!this->in.valid) throw dzn::binding_error (this->dzn_meta, "in.valid");
}
namespace dzn
{
}
ISensor::ISensor (dzn::port::meta const& m)
: dzn_meta (m)
, dzn_share_p (true)
, dzn_label ("")
, dzn_state ()
{}
ISensor::~ISensor ()= default;
void
ISensor::dzn_event (char const* event)
{
  if (!dzn_share_p) return;
  dzn_label = event;
}
void
ISensor::dzn_update_state (dzn::locator const& locator)
{
  if (!dzn_share_p || !dzn_label) return;
  switch (dzn::hash (dzn_label, dzn_state))
    {
      case 1414409102u:
      //0:MovementDetected
      dzn_state = 0;
      break;
      default: locator.get<dzn::illegal_handler> ().handle (LOCATION);
    }
}
void
ISensor::dzn_check_bindings ()
{
  if (!this->out.MovementDetected) throw dzn::binding_error (this->dzn_meta, "out.MovementDetected");
}
namespace dzn
{
}
ISiren::ISiren (dzn::port::meta const& m)
: dzn_meta (m)
, dzn_share_p (true)
, dzn_label ("")
, dzn_state ()
, enabled (false)
{}
ISiren::~ISiren ()= default;
void
ISiren::dzn_event (char const* event)
{
  if (!dzn_share_p) return;
  dzn_label = event;
}
void
ISiren::dzn_update_state (dzn::locator const& locator)
{
  if (!dzn_share_p || !dzn_label) return;
  switch (dzn::hash (dzn_label, dzn_state))
    {
      case 1887990968u:
      //0:disable
      dzn_state = 3;
      break;
      case 1924237964u:
      //0:enable
      dzn_state = 4;
      break;
      case 632232382u:
      //1:return
      dzn_state = 0;
      enabled = false;
      break;
      case 1887991126u:
      //2:disable
      dzn_state = 1;
      break;
      case 1924238122u:
      //2:enable
      dzn_state = 3;
      break;
      case 632232619u:
      //4:return
      dzn_state = 2;
      enabled = true;
      break;
      default: locator.get<dzn::illegal_handler> ().handle (LOCATION);
    }
}
void
ISiren::dzn_check_bindings ()
{
  if (!this->in.disable) throw dzn::binding_error (this->dzn_meta, "in.disable");
  if (!this->in.enable) throw dzn::binding_error (this->dzn_meta, "in.enable");
}
namespace dzn
{
}
ITimer::ITimer (dzn::port::meta const& m)
: dzn_meta (m)
, dzn_share_p (true)
, dzn_label ("")
, dzn_state ()
, idle (true)
{}
ITimer::~ITimer ()= default;
void
ITimer::dzn_event (char const* event)
{
  if (!dzn_share_p) return;
  dzn_label = event;
}
void
ITimer::dzn_update_state (dzn::locator const& locator)
{
  if (!dzn_share_p || !dzn_label) return;
  switch (dzn::hash (dzn_label, dzn_state))
    {
      case 3877589605u:
      //0:cancel
      dzn_state = 1;
      break;
      case 2714604162u:
      //0:set
      dzn_state = 4;
      break;
      case 632232382u:
      //1:return
      dzn_state = 0;
      idle = true;
      break;
      case 3877589763u:
      //2:cancel
      dzn_state = 1;
      break;
      case 2714604320u:
      //2:set
      dzn_state = 4;
      break;
      case 2854436095u:
      //2:timeout
      dzn_state = 0;
      idle = true;
      break;
      case 632232619u:
      //4:return
      dzn_state = 2;
      idle = false;
      break;
      default: locator.get<dzn::illegal_handler> ().handle (LOCATION);
    }
}
void
ITimer::dzn_check_bindings ()
{
  if (!this->in.set) throw dzn::binding_error (this->dzn_meta, "in.set");
  if (!this->in.cancel) throw dzn::binding_error (this->dzn_meta, "in.cancel");
  if (!this->out.timeout) throw dzn::binding_error (this->dzn_meta, "out.timeout");
}
namespace dzn
{
}
// version 2.18.0
