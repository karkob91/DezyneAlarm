// Generated by dzn code from /home/karol/dev_projects/VerumESP32/DezyneAlarm/src/alarm-interfaces.dzn
// Dezyne --- Dezyne command line tools
// Copyright Â© 2024Karol Kobiela <karol.kobiela@verum.com>
//
// This file is part of Dezyne.
//
// Dezyne is free software: you can redistribute it and/or modify it
// under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// Dezyne is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public
// License along with Dezyne.  If not, see <http://www.gnu.org/licenses/>.
//
// Commentary:
//
// These models represent the actors of the alarm component.
//
// Code:
#include <dzn/runtime.hh>
namespace dzn
{
  struct locator;
  struct runtime;
}
#include <iostream>
#include <vector>
#include <map>
#ifndef ICONSOLE_HH
#define ICONSOLE_HH
struct IConsole
{
  enum struct State
    {
      Disarmed,Arming,Armed,Triggered
    };
  dzn::port::meta dzn_meta;
  struct
    {
      dzn::in::event<bool (int pin)> arm;
    } in;
  struct
    {
      dzn::out::event<void ()> armed;
      dzn::out::event<void ()> disarmed;
      dzn::out::event<void ()> arming;
      dzn::out::event<void ()> detected;
    } out;
  bool dzn_share_p;
  char const* dzn_label;
  int dzn_state;
  ::IConsole::State state;
  IConsole (dzn::port::meta const& m);
  template <typename Component>
  IConsole (dzn::port::meta const& m, Component* that)
  : dzn_meta (m)
  , dzn_share_p (true)
  , dzn_label ("")
  , dzn_state ()
  , state (::IConsole::State::Disarmed)
    {
      in.arm.set (that, this, "arm");
      out.armed.set (that, this, "armed");
      out.disarmed.set (that, this, "disarmed");
      out.arming.set (that, this, "arming");
      out.detected.set (that, this, "detected");
    }
  virtual ~IConsole ();
  void dzn_event (char const* event);
  void dzn_update_state (dzn::locator const& locator);
  void dzn_check_bindings ();
};
namespace dzn
{
  inline void connect (::IConsole& provide, ::IConsole& require)
    {
      provide.out.armed = require.out.armed;
      provide.out.disarmed = require.out.disarmed;
      provide.out.arming = require.out.arming;
      provide.out.detected = require.out.detected;
      require.in.arm = provide.in.arm;
      provide.dzn_meta.require = require.dzn_meta.require;
      require.dzn_meta.provide = provide.dzn_meta.provide;
      provide.dzn_share_p = require.dzn_share_p = provide.dzn_share_p && require.dzn_share_p;
    }
}
#endif // ICONSOLE_HH
#ifndef IPIN_HH
#define IPIN_HH
struct IPin
{
  dzn::port::meta dzn_meta;
  struct
    {
      dzn::in::event<bool (int pin)> valid;
    } in;
  struct
    {
    } out;
  bool dzn_share_p;
  char const* dzn_label;
  int dzn_state;
  IPin (dzn::port::meta const& m);
  template <typename Component>
  IPin (dzn::port::meta const& m, Component* that)
  : dzn_meta (m)
  , dzn_share_p (true)
  , dzn_label ("")
  , dzn_state ()
    {
      in.valid.set (that, this, "valid");
    }
  virtual ~IPin ();
  void dzn_event (char const* event);
  void dzn_update_state (dzn::locator const& locator);
  void dzn_check_bindings ();
};
namespace dzn
{
  inline void connect (::IPin& provide, ::IPin& require)
    {
      require.in.valid = provide.in.valid;
      provide.dzn_meta.require = require.dzn_meta.require;
      require.dzn_meta.provide = provide.dzn_meta.provide;
      provide.dzn_share_p = require.dzn_share_p = provide.dzn_share_p && require.dzn_share_p;
    }
}
#endif // IPIN_HH
#ifndef ISENSOR_HH
#define ISENSOR_HH
struct ISensor
{
  dzn::port::meta dzn_meta;
  struct
    {
    } in;
  struct
    {
      dzn::out::event<void ()> MovementDetected;
    } out;
  bool dzn_share_p;
  char const* dzn_label;
  int dzn_state;
  ISensor (dzn::port::meta const& m);
  template <typename Component>
  ISensor (dzn::port::meta const& m, Component* that)
  : dzn_meta (m)
  , dzn_share_p (true)
  , dzn_label ("")
  , dzn_state ()
    {
      out.MovementDetected.set (that, this, "MovementDetected");
    }
  virtual ~ISensor ();
  void dzn_event (char const* event);
  void dzn_update_state (dzn::locator const& locator);
  void dzn_check_bindings ();
};
namespace dzn
{
  inline void connect (::ISensor& provide, ::ISensor& require)
    {
      provide.out.MovementDetected = require.out.MovementDetected;
      provide.dzn_meta.require = require.dzn_meta.require;
      require.dzn_meta.provide = provide.dzn_meta.provide;
      provide.dzn_share_p = require.dzn_share_p = provide.dzn_share_p && require.dzn_share_p;
    }
}
#endif // ISENSOR_HH
#ifndef ISIREN_HH
#define ISIREN_HH
struct ISiren
{
  dzn::port::meta dzn_meta;
  struct
    {
      dzn::in::event<void ()> disable;
      dzn::in::event<void ()> enable;
    } in;
  struct
    {
    } out;
  bool dzn_share_p;
  char const* dzn_label;
  int dzn_state;
  bool enabled;
  ISiren (dzn::port::meta const& m);
  template <typename Component>
  ISiren (dzn::port::meta const& m, Component* that)
  : dzn_meta (m)
  , dzn_share_p (true)
  , dzn_label ("")
  , dzn_state ()
  , enabled (false)
    {
      in.disable.set (that, this, "disable");
      in.enable.set (that, this, "enable");
    }
  virtual ~ISiren ();
  void dzn_event (char const* event);
  void dzn_update_state (dzn::locator const& locator);
  void dzn_check_bindings ();
};
namespace dzn
{
  inline void connect (::ISiren& provide, ::ISiren& require)
    {
      require.in.disable = provide.in.disable;
      require.in.enable = provide.in.enable;
      provide.dzn_meta.require = require.dzn_meta.require;
      require.dzn_meta.provide = provide.dzn_meta.provide;
      provide.dzn_share_p = require.dzn_share_p = provide.dzn_share_p && require.dzn_share_p;
    }
}
#endif // ISIREN_HH
#ifndef ITIMER_HH
#define ITIMER_HH
struct ITimer
{
  dzn::port::meta dzn_meta;
  struct
    {
      dzn::in::event<void (int delay)> set;
      dzn::in::event<void ()> cancel;
    } in;
  struct
    {
      dzn::out::event<void ()> timeout;
    } out;
  bool dzn_share_p;
  char const* dzn_label;
  int dzn_state;
  bool idle;
  ITimer (dzn::port::meta const& m);
  template <typename Component>
  ITimer (dzn::port::meta const& m, Component* that)
  : dzn_meta (m)
  , dzn_share_p (true)
  , dzn_label ("")
  , dzn_state ()
  , idle (true)
    {
      in.set.set (that, this, "set");
      in.cancel.set (that, this, "cancel");
      out.timeout.set (that, this, "timeout");
    }
  virtual ~ITimer ();
  void dzn_event (char const* event);
  void dzn_update_state (dzn::locator const& locator);
  void dzn_check_bindings ();
};
namespace dzn
{
  inline void connect (::ITimer& provide, ::ITimer& require)
    {
      provide.out.timeout = require.out.timeout;
      require.in.set = provide.in.set;
      require.in.cancel = provide.in.cancel;
      provide.dzn_meta.require = require.dzn_meta.require;
      require.dzn_meta.provide = provide.dzn_meta.provide;
      provide.dzn_share_p = require.dzn_share_p = provide.dzn_share_p && require.dzn_share_p;
    }
}
#endif // ITIMER_HH
// version 2.18.0
